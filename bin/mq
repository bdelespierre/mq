#!/usr/bin/env bash
#
# mq - MySQL/MariaDB client wrapper with argument expansion and SQL shorthand
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Source library functions
source "$PROJECT_ROOT/lib/mq/transform.bash"

# Version
VERSION="1.4.3"

# Global options
declare -a MYSQL_OPTIONS=()
FORMAT="table"
QUIET=0
DRY_RUN=0
INPUT_FILE=""
DEBUG="${DEBUG:-0}"
COLOR="auto"  # auto, always, never

# Default format: table for TTY, tsv for pipes
if [[ ! -t 1 ]]; then
    FORMAT="tsv"
fi

# Debug helper: prints message to stderr when DEBUG=1
debug() {
    [[ "$DEBUG" == "1" ]] && >&2 echo -e "\e[33m[debug]\e[0m $*"
    return 0
}

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [--] [ARGUMENT]... [+]

MySQL/MariaDB client wrapper with argument expansion and SQL shorthand helpers.
When last argument is +, display query result vertically (equivalent of \G).

Options:
    -h, --help                 Show this help message and exit
    -v, --version              Show version and exit
    -o, --option NAME[=VALUE]  Set MySQL/MariaDB client option (see mysql --help)
    -f, --format NAME          Output format: table, vertical, html, xml, or tsv
                               Default: table (TTY) or tsv (pipe)
    -q, --quiet                Suppress query echo to stderr
    -n, --dry-run              Show query without executing
    -i, --input FILE           Read query from file (use - for stdin)
        --color[=WHEN]         Colorize output (requires grcat): auto, always, never
                               Default: auto (color when stdout is a TTY)

Arguments:
    :VALUE             Shorthand for %string VALUE
    %s, %string VALUE  Treat value as a string
    %j, %json VALUE    Treat value as a JSON path

    %a, %all           Alias of *
    %c, %count         Alias of COUNT(*)
    %r, %rand          Alias of RAND()
        %now           Alias of NOW()
        %eq            Alias of =
        %ne            Alias of <> or !=
        %gt            Alias of >
        %gte           Alias of >=
        %lt            Alias of <
        %lte           Alias of <=
        %in VALUES     Alias of IN (VALUES)

Examples:
    $(basename "$0") -o database=mydb select %count from users where birthdate %gt :2000-01-01
    PAGER=less $(basename "$0") select %a from users where email=:john.doe@example.com +

Configuration:
    Options are loaded from (in order, later overrides earlier):
        1. ~/.mqrc                     Global defaults
        2. ./.mqrc                     Project-local overrides
           ./.mqrc.dist                (fallback if .mqrc missing)

    Config files are sourced as bash:
        MYSQL_OPTIONS+=(
            --host=localhost
            --database=mydb
        )
        FORMAT=table
        QUIET=1

    Override global config location with MQRC environment variable.

EOF
}

# Load configuration from ~/.mqrc and ./.mqrc
load_config() {
    local config_file="${MQRC:-$HOME/.mqrc}"

    # Global config
    if [[ -f "$config_file" ]]; then
        debug "Loading global config: $config_file"

        # shellcheck disable=SC1090
        source "$config_file"
    else
        debug "Global config not found: $config_file"
    fi

    # Project-local config (overrides/augments global)
    local local_config=""
    if [[ -f ".mqrc" ]]; then
        local_config=".mqrc"
    elif [[ -f ".mqrc.dist" ]]; then
        local_config=".mqrc.dist"
    fi

    if [[ -n "$local_config" ]]; then
        debug "Loading local config: $PWD/$local_config"

        # shellcheck disable=SC1090
        source "$local_config"
    else
        debug "No local config found (.mqrc or .mqrc.dist)"
    fi
}

# Apply format to MySQL options array
apply_format() {
    debug "Applying format: $FORMAT"

    case "$FORMAT" in
        table)    MYSQL_OPTIONS+=("--table") ;;
        vertical) MYSQL_OPTIONS+=("--vertical") ;;
        html)     MYSQL_OPTIONS+=("--html") ;;
        xml)      MYSQL_OPTIONS+=("--xml") ;;
        tsv)      MYSQL_OPTIONS+=("--silent") ;;
        *)
            >&2 echo "Invalid format: $FORMAT"
            return 1
            ;;
    esac
}

# Execute the query
execute_query() {
    local sql="$1"
    local pager

    # Determine pager based on COLOR setting and PAGER env
    if [[ -n "${PAGER:-}" ]]; then
        pager="$PAGER"
    elif [[ "$COLOR" == "always" ]] && command -v grcat &>/dev/null; then
        pager="grcat conf.mq"
    elif [[ "$COLOR" == "never" ]]; then
        pager="cat"
    elif [[ "$COLOR" == "auto" && -t 1 ]] && command -v grcat &>/dev/null; then
        pager="grcat conf.mq"
    else
        pager="cat"
    fi

    debug "SQL: $sql"
    debug "MySQL options: ${MYSQL_OPTIONS[*]}"
    debug "PAGER: $pager"

    # Dry-run mode: print query and exit
    if [[ $DRY_RUN -eq 1 ]]; then
        debug "Dry-run mode: printing query without executing"
        echo "$sql"
        return 0
    fi

    # Print the query to stderr (dimmed) unless quiet mode
    if [[ $QUIET -eq 0 ]]; then
        >&2 echo -e "> \e[2m$sql\e[0m"
    fi

    # Execute and pipe through pager
    debug "Executing: mysql ${MYSQL_OPTIONS[*]}"
    mysql "${MYSQL_OPTIONS[@]}" <<< "$sql" | $pager
}

main() {
    debug "mq version $VERSION"
    debug "TTY detected: $([[ -t 1 ]] && echo "yes" || echo "no")"
    debug "Default format: $FORMAT"

    # Load config file defaults (can be overridden by CLI options)
    load_config

    # Parse options with getopt
    local opts
    if ! opts=$(getopt -o hvo:f:qni: --long help,version,option:,format:,quiet,dry-run,input:,color:: -n "$(basename "$0")" -- "$@"); then
        >&2 usage
        exit 1
    fi
    eval set -- "$opts"

    while true; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "mq $VERSION"
                exit 0
                ;;
            -o|--option)
                debug "Option: -o $2"
                # Handle MySQL options (convert to --name or -n format)
                if [[ "$2" =~ ^[^=]{2} ]]; then
                    MYSQL_OPTIONS+=("--$2")
                else
                    MYSQL_OPTIONS+=("-$2")
                fi
                shift 2
                ;;
            -f|--format)
                debug "Option: -f $2"
                FORMAT="$2"
                shift 2
                ;;
            -q|--quiet)
                debug "Option: -q (quiet mode)"
                QUIET=1
                shift
                ;;
            -n|--dry-run)
                debug "Option: -n (dry-run mode)"
                DRY_RUN=1
                shift
                ;;
            -i|--input)
                debug "Option: -i $2"
                INPUT_FILE="$2"
                shift 2
                ;;
            --color)
                # Optional argument: empty string means no value provided
                if [[ -z "$2" ]]; then
                    COLOR="always"
                elif [[ "$2" =~ ^(auto|always|never)$ ]]; then
                    COLOR="$2"
                else
                    >&2 echo "Invalid --color value: $2 (must be auto, always, or never)"
                    exit 1
                fi
                debug "Option: --color=$COLOR"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                >&2 echo "Unexpected option: $1"
                exit 1
                ;;
        esac
    done

    debug "Final options: FORMAT=$FORMAT QUIET=$QUIET DRY_RUN=$DRY_RUN INPUT_FILE=$INPUT_FILE"

    # Apply the selected format
    apply_format || exit 1

    local sql=""

    # Read query from input file or stdin
    if [[ -n "$INPUT_FILE" ]]; then
        if [[ "$INPUT_FILE" == "-" ]]; then
            debug "Reading from stdin"
            sql=$(cat)
        elif [[ -f "$INPUT_FILE" ]]; then
            debug "Reading query from input file: $INPUT_FILE"
            sql=$(cat "$INPUT_FILE")
        else
            >&2 echo "File not found: $INPUT_FILE"
            exit 1
        fi
        debug "Query from file: $sql"
    else
        # Check for query arguments
        if [[ $# -eq 0 ]]; then
            >&2 echo "No query specified"
            >&2 usage
            exit 1
        fi

        debug "Query arguments: $*"

        # Build the query from arguments
        local vertical_requested=""
        build_query sql vertical_requested "$@"

        debug "Built query: $sql"
        debug "Vertical requested: $vertical_requested"

        [[ "$vertical_requested" == 1 ]] && MYSQL_OPTIONS+=("--vertical")
    fi

    # Execute the query
    execute_query "$sql"
}

main "$@"
